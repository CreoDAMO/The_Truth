// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol";
import "@openzeppelin/contracts/token/common/ERC2981.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/security/PullPayment.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

/**
 * @title Enhanced The Truth NFT Contract
 * @notice Advanced NFT contract with batch minting, whitelist, dynamic pricing, and cross-collection benefits
 */
contract EnhancedTheTruth is ERC721, ERC721Enumerable, ERC721Pausable, ERC2981, Ownable, AccessControl, ReentrancyGuard, PullPayment {
    using Strings for uint256;
    using Counters for Counters.Counter;

    // Collection constants
    uint256 public constant MAX_SUPPLY = 77;
    uint256 public constant PUBLIC_SUPPLY = 76;
    uint256 public constant MASTER_COPY_ID = 77;
    uint256 public constant BASE_PRICE = 169548481700983700; // ~0.169548 ETH ($777)
    uint256 public constant MAX_BATCH_SIZE = 5;

    // Dynamic pricing parameters
    uint256 public currentPrice = BASE_PRICE;
    uint256 public priceIncrementBasis = 5; // 5% increase every 10 mints
    uint256 public priceIncrementThreshold = 10;

    // Collection state
    Counters.Counter private _tokenIdCounter;
    string private _baseTokenURI;
    bool public mintingEnabled = false;
    bool public whitelistMintEnabled = false;
    bool public publicMintEnabled = false;

    // Minting limits and tracking
    mapping(address => uint256) public mintedCount;
    mapping(address => bool) public hasMintedWhitelist;
    uint256 public constant MAX_PER_WALLET = 2;
    uint256 public constant MAX_PER_WHITELIST = 1;

    // Whitelist functionality
    bytes32 public merkleRoot;
    mapping(address => bool) public whitelist;
    uint256 public whitelistPrice = BASE_PRICE * 80 / 100; // 20% discount

    // Cross-collection benefits
    mapping(address => bool) public partnerCollections;
    mapping(address => uint256) public holderDiscounts; // Basis points (e.g., 1000 = 10%)

    // Provenance and treasury
    string public provenance;
    bool private provenanceLocked = false;
    address public treasury;
    bool public treasuryIsMultisig = false;

    // Role for pausing/unpausing
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

    // Enhanced events
    event MintingToggled(bool enabled);
    event WhitelistMintToggled(bool enabled);
    event PublicMintToggled(bool enabled);
    event BaseURIUpdated(string newBaseURI);
    event TruthMinted(address indexed to, uint256 indexed tokenId, uint256 price, string mintType);
    event BatchMinted(address indexed to, uint256[] tokenIds, uint256 totalPrice, uint256 quantity);
    event ProvenanceSet(string provenance);
    event TreasuryUpdated(address treasury, bool multisig);
    event PriceUpdated(uint256 oldPrice, uint256 newPrice, uint256 totalMinted);
    event WhitelistUpdated(bytes32 merkleRoot);
    event PartnerCollectionAdded(address collection, uint256 discount);
    event HolderDiscountClaimed(address holder, address partnerCollection, uint256 discount);

    constructor(
        address initialOwner,
        string memory baseURI,
        address initialTreasury
    ) ERC721("The Truth Enhanced", "TRUTHX") Ownable(initialOwner) {
        _transferOwnership(initialOwner);
        _baseTokenURI = baseURI;
        _grantRole(DEFAULT_ADMIN_ROLE, initialOwner);
        _grantRole(PAUSER_ROLE, initialOwner);
        treasury = initialTreasury;

        // Set default royalty to 10% (1000 basis points)
        _setDefaultRoyalty(initialTreasury, 1000);

        // Mint master copy #77 to owner
        _safeMint(initialOwner, MASTER_COPY_ID);
        emit TruthMinted(initialOwner, MASTER_COPY_ID, 0, "master");
    }

    /**
     * @notice Whitelist minting with merkle proof verification
     * @param proof Merkle proof for whitelist verification
     */
    function mintWhitelist(bytes32[] calldata proof) external payable nonReentrant {
        require(mintingEnabled, "Minting not enabled");
        require(whitelistMintEnabled, "Whitelist minting not enabled");
        require(!paused(), "Contract is paused");
        require(_tokenIdCounter.current() <= PUBLIC_SUPPLY, "Public supply exhausted");
        require(!hasMintedWhitelist[msg.sender], "Already minted whitelist allocation");
        require(msg.value >= whitelistPrice, "Insufficient payment for whitelist");

        // Verify merkle proof
        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
        require(MerkleProof.verify(proof, merkleRoot, leaf), "Invalid whitelist proof");

        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();

        _safeMint(msg.sender, tokenId);
        hasMintedWhitelist[msg.sender] = true;
        mintedCount[msg.sender] += 1;

        // Refund excess payment
        if (msg.value > whitelistPrice) {
            payable(msg.sender).transfer(msg.value - whitelistPrice);
        }

        emit TruthMinted(msg.sender, tokenId, whitelistPrice, "whitelist");
    }

    /**
     * @notice Public minting with dynamic pricing
     * @param quantity Number of tokens to mint (1-5)
     */
    function mintPublic(uint256 quantity) external payable nonReentrant {
        require(mintingEnabled, "Minting not enabled");
        require(publicMintEnabled, "Public minting not enabled");
        require(!paused(), "Contract is paused");
        require(quantity > 0 && quantity <= MAX_BATCH_SIZE, "Invalid quantity");
        require(_tokenIdCounter.current() + quantity - 1 <= PUBLIC_SUPPLY, "Would exceed max supply");
        require(mintedCount[msg.sender] + quantity <= MAX_PER_WALLET, "Exceeds wallet limit");

        uint256 totalPrice = calculateTotalPrice(quantity);
        uint256 discountedPrice = applyHolderDiscount(msg.sender, totalPrice);

        require(msg.value >= discountedPrice, "Insufficient payment");

        uint256[] memory tokenIds = new uint256[](quantity);

        for (uint256 i = 0; i < quantity; i++) {
            uint256 tokenId = _tokenIdCounter.current();
            _tokenIdCounter.increment();
            tokenIds[i] = tokenId;
            _safeMint(msg.sender, tokenId);
        }

        mintedCount[msg.sender] += quantity;
        updateDynamicPricing();

        // Refund excess payment
        if (msg.value > discountedPrice) {
            payable(msg.sender).transfer(msg.value - discountedPrice);
        }

        if (quantity == 1) {
            emit TruthMinted(msg.sender, tokenIds[0], discountedPrice, "public");
        } else {
            emit BatchMinted(msg.sender, tokenIds, discountedPrice, quantity);
        }
    }

    /**
     * @notice Calculate total price for quantity with dynamic pricing
     * @param quantity Number of tokens to mint
     * @return Total price in wei
     */
    function calculateTotalPrice(uint256 quantity) public view returns (uint256) {
        uint256 totalPrice = 0;
        uint256 tempPrice = currentPrice;
        uint256 tempMinted = totalMinted();

        for (uint256 i = 0; i < quantity; i++) {
            totalPrice += tempPrice;
            tempMinted++;

            // Update price for next token if threshold reached
            if (tempMinted % priceIncrementThreshold == 0) {
                tempPrice = tempPrice * (10000 + priceIncrementBasis * 100) / 10000;
            }
        }

        return totalPrice;
    }

    /**
     * @notice Apply holder discount based on partner collection ownership
     * @param holder Address to check for discounts
     * @param price Original price
     * @return Discounted price
     */
    function applyHolderDiscount(address holder, uint256 price) public view returns (uint256) {
        uint256 maxDiscount = 0;

        // Iterate through registered partner collections to find the maximum discount
        // In a real-world scenario, you'd have a more robust way to manage partner collections,
        // perhaps an array or mapping that stores addresses and their discounts.
        // For this example, we'll simulate checking a few potential partner addresses.
        address[] memory potentialPartners = new address[](3); // Example: check up to 3 partner contracts
        potentialPartners[0] = address(0xabc123000000000000000000000000000000000); // Replace with actual partner contract addresses
        potentialPartners[1] = address(0xdef456000000000000000000000000000000000);
        potentialPartners[2] = address(0x123789000000000000000000000000000000000);


        for (uint256 i = 0; i < potentialPartners.length; i++) {
            address partnerAddr = potentialPartners[i];
            if (partnerCollections[partnerAddr]) { // Check if it's a registered partner collection
                // Check if the holder owns at least one NFT from the partner collection
                try IERC721(partnerAddr).balanceOf(holder) returns (uint256 balance) {
                    if (balance > 0 && holderDiscounts[partnerAddr] > maxDiscount) {
                        maxDiscount = holderDiscounts[partnerAddr];
                    }
                } catch {
                    // Skip if contract call fails or partner contract is not ERC721 compliant
                }
            }
        }

        if (maxDiscount > 0) {
            uint256 discount = price * maxDiscount / 10000;
            return price - discount;
        }

        return price;
    }

    /**
     * @notice Update dynamic pricing based on current minting progress
     */
    function updateDynamicPricing() internal {
        uint256 minted = totalMinted();
        if (minted % priceIncrementThreshold == 0 && minted > 0) {
            uint256 oldPrice = currentPrice;
            currentPrice = currentPrice * (10000 + priceIncrementBasis * 100) / 10000;
            emit PriceUpdated(oldPrice, currentPrice, minted);
        }
    }

    // Owner functions
    function toggleMinting() external onlyRole(DEFAULT_ADMIN_ROLE) {
        mintingEnabled = !mintingEnabled;
        emit MintingToggled(mintingEnabled);
    }

    function toggleWhitelistMint() external onlyRole(DEFAULT_ADMIN_ROLE) {
        whitelistMintEnabled = !whitelistMintEnabled;
        emit WhitelistMintToggled(whitelistMintEnabled);
    }

    function togglePublicMint() external onlyRole(DEFAULT_ADMIN_ROLE) {
        publicMintEnabled = !publicMintEnabled;
        emit PublicMintToggled(publicMintEnabled);
    }

    function setMerkleRoot(bytes32 _merkleRoot) external onlyRole(DEFAULT_ADMIN_ROLE) {
        merkleRoot = _merkleRoot;
        emit WhitelistUpdated(_merkleRoot);
    }

    function addPartnerCollection(address collection, uint256 discountBasisPoints) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(discountBasisPoints <= 3000, "Discount too high"); // Max 30%
        partnerCollections[collection] = true;
        holderDiscounts[collection] = discountBasisPoints;
        emit PartnerCollectionAdded(collection, discountBasisPoints);
    }

    function removePartnerCollection(address collection) external onlyRole(DEFAULT_ADMIN_ROLE) {
        partnerCollections[collection] = false;
        holderDiscounts[collection] = 0;
    }

    function setDynamicPricing(uint256 incrementBasis, uint256 threshold) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(incrementBasis <= 20, "Increment too high"); // Max 20%
        require(threshold >= 5 && threshold <= 20, "Invalid threshold");
        priceIncrementBasis = incrementBasis;
        priceIncrementThreshold = threshold;
    }

    function setCurrentPrice(uint256 newPrice) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(newPrice >= BASE_PRICE / 2 && newPrice <= BASE_PRICE * 3, "Price out of range");
        uint256 oldPrice = currentPrice;
        currentPrice = newPrice;
        emit PriceUpdated(oldPrice, newPrice, totalMinted());
    }

    function setWhitelistPrice(uint256 newPrice) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(newPrice <= BASE_PRICE, "Whitelist price too high");
        whitelistPrice = newPrice;
    }

    function setBaseURI(string calldata newBaseURI) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _baseTokenURI = newBaseURI;
        emit BaseURIUpdated(newBaseURI);
    }

    function setProvenance(string calldata prov) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(!provenanceLocked, "Provenance locked");
        provenance = prov;
        provenanceLocked = true;
        emit ProvenanceSet(prov);
    }

    function setTreasury(address _treasury, bool _isMultisig) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_treasury != address(0), "Zero address");
        treasury = _treasury;
        treasuryIsMultisig = _isMultisig;
        emit TreasuryUpdated(_treasury, _isMultisig);
    }

    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {
        uint256 balance = address(this).balance;
        require(balance > 0, "No funds to withdraw");
        address payable dest = payable(treasury == address(0) ? owner() : treasury);
        (bool success, ) = dest.call{value: balance}("");
        require(success, "Withdrawal failed");
    }

    // View functions
    function totalMinted() public view returns (uint256) {
        // Subtract 1 to exclude the master copy if it was minted
        return _tokenIdCounter.current() > 0 ? _tokenIdCounter.current() - 1 : 0;
    }

    function publicMinted() external view returns (uint256) {
        uint256 total = totalMinted();
        return total > 0 ? total - 1 : 0; // Exclude master copy
    }

    function remainingSupply() external view returns (uint256) {
        if (_tokenIdCounter.current() > PUBLIC_SUPPLY) return 0;
        return PUBLIC_SUPPLY - _tokenIdCounter.current();
    }

    function getCurrentPrice() external view returns (uint256) {
        return currentPrice;
    }

    function getWhitelistPrice() external view returns (uint256) {
        return whitelistPrice;
    }

    function isWhitelisted(address account, bytes32[] calldata proof) external view returns (bool) {
        bytes32 leaf = keccak256(abi.encodePacked(account));
        return MerkleProof.verify(proof, merkleRoot, leaf);
    }

    function getHolderDiscount(address holder) external view returns (uint256) {
        uint256 totalPrice = currentPrice;
        uint256 discountedPrice = applyHolderDiscount(holder, totalPrice);
        return totalPrice - discountedPrice;
    }

    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        // Ensure the base URI ends with a slash if it doesn't already
        string memory baseURI = _baseTokenURI;
        if (bytes(baseURI).length > 0 && baseURI[bytes(baseURI).length-1] != '/') {
            baseURI = string(abi.encodePacked(baseURI, "/"));
        }
        return string(abi.encodePacked(baseURI, tokenId.toString(), ".json"));
    }

    // Emergency functions
    function pause() external onlyRole(PAUSER_ROLE) {
        _pause();
    }

    function unpause() external onlyRole(PAUSER_ROLE) {
        _unpause();
    }

    // Required overrides
    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize)
        internal
        override(ERC721, ERC721Enumerable, ERC721Pausable)
    {
        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721Enumerable, ERC2981, AccessControl)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    // Set default royalty for the collection
    function setDefaultRoyalty(address receiver, uint96 feeNumerator) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(feeNumerator <= 1000, "Royalty fee too high"); // Max 10%
        _setDefaultRoyalty(receiver, feeNumerator);
    }
}